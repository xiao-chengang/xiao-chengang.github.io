<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农的自我修养</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xiao-chengang.github.io/"/>
  <updated>2018-02-26T08:33:00.000Z</updated>
  <id>http://xiao-chengang.github.io/</id>
  
  <author>
    <name>肖晨刚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo配置</title>
    <link href="http://xiao-chengang.github.io/2018/02/22/hexo-config/"/>
    <id>http://xiao-chengang.github.io/2018/02/22/hexo-config/</id>
    <published>2018-02-22T08:04:05.000Z</published>
    <updated>2018-02-26T08:33:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整站配置"><a href="#整站配置" class="headerlink" title="整站配置"></a>整站配置</h1><p>您可以在 _config.yml 中修改大部份的配置。</p><a id="more"></a><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">title</td><td style="text-align:left">网站标题</td></tr><tr><td style="text-align:left">subtitle</td><td style="text-align:left">网站副标题</td></tr><tr><td style="text-align:left">description</td><td style="text-align:left">网站描述</td></tr><tr><td style="text-align:left">author</td><td style="text-align:left">您的名字</td></tr><tr><td style="text-align:left">language</td><td style="text-align:left">网站使用的语言</td></tr><tr><td style="text-align:left">timezone</td><td style="text-align:left">网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。</td></tr></tbody></table><p>其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p><h2 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">url</td><td style="text-align:left">网址</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">root</td><td style="text-align:left">网站根目录</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">permalink</td><td style="text-align:left">文章的 永久链接 格式</td><td style="text-align:left">:year/:month/:day/:title/</td></tr><tr><td style="text-align:left">permalink_defaults</td><td style="text-align:left">永久链接中各部分的默认值</td></tr></tbody></table><blockquote><p>网站存放在子目录<br>如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">source_dir</td><td style="text-align:left">资源文件夹，这个文件夹用来存放内容。</td><td style="text-align:left">source</td></tr><tr><td style="text-align:left">public_dir</td><td style="text-align:left">公共文件夹，这个文件夹用于存放生成的站点文件。</td><td style="text-align:left">public</td></tr><tr><td style="text-align:left">tag_dir</td><td style="text-align:left">标签文件夹</td><td style="text-align:left">tags</td></tr><tr><td style="text-align:left">archive_dir</td><td style="text-align:left">归档文件夹</td><td style="text-align:left">archives</td></tr><tr><td style="text-align:left">category_dir</td><td style="text-align:left">分类文件夹</td><td style="text-align:left">categories</td></tr><tr><td style="text-align:left">code_dir</td><td style="text-align:left">Include code 文件夹</td><td style="text-align:left">downloads/code</td></tr><tr><td style="text-align:left">i18n_dir</td><td style="text-align:left">国际化（i18n）文件夹</td><td style="text-align:left">:lang</td></tr><tr><td style="text-align:left">skip_render</td><td style="text-align:left">跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。</td></tr></tbody></table><blockquote><p>如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。</p></blockquote><h2 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">new_post_name</td><td style="text-align:left">新文章的文件名称</td><td style="text-align:left">:title.md</td></tr><tr><td style="text-align:left">default_layout</td><td style="text-align:left">预设布局</td><td style="text-align:left">post</td></tr><tr><td style="text-align:left">auto_spacing</td><td style="text-align:left">在中文和英文之间加入空格</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">titlecase</td><td style="text-align:left">把标题转换为 title case</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">external_link</td><td style="text-align:left">在新标签中打开链接</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">filename_case</td><td style="text-align:left">把文件名称转换为 (1) 小写或 (2) 大写</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">render_drafts</td><td style="text-align:left">显示草稿</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">post_asset_folder</td><td style="text-align:left">启动 Asset 文件夹</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">relative_link</td><td style="text-align:left">把链接改为与根目录的相对位址</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">future</td><td style="text-align:left">显示未来的文章</td><td style="text-align:left">true</td></tr><tr><td style="text-align:left">highlight</td><td style="text-align:left">代码块的设置</td></tr></tbody></table><blockquote><h3 id="相对地址"><a href="#相对地址" class="headerlink" title="相对地址"></a>相对地址</h3><p>默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：<a href="http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。" target="_blank" rel="noopener">http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</a></p></blockquote><h2 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">default_category</td><td style="text-align:left">默认分类</td><td style="text-align:left">uncategorized</td></tr><tr><td style="text-align:left">category_map</td><td style="text-align:left">分类别名</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">tag_map</td><td style="text-align:left">标签别名</td></tr></tbody></table><h2 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h2><p>Hexo 使用 Moment.js 来解析和显示时间。<br>|参数    |描述    |默认值|<br>|:–|:–|:–|<br>|date_format    |日期格式    |YYYY-MM-DD|<br>|time_format    |时间格式    |H:mm:ss|</p><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th><th style="text-align:left">默认值</th></tr></thead><tbody><tr><td style="text-align:left">per_page</td><td style="text-align:left">每页显示的文章量 (0 = 关闭分页功能)</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">pagination_dir</td><td style="text-align:left">分页目录</td><td style="text-align:left">page</td></tr></tbody></table><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">theme</td><td style="text-align:left">当前主题名称。值为false时禁用主题</td></tr><tr><td style="text-align:left">deploy</td><td style="text-align:left">部署部分的设置</td></tr></tbody></table><!-- # 主题配置 -->]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;整站配置&quot;&gt;&lt;a href=&quot;#整站配置&quot; class=&quot;headerlink&quot; title=&quot;整站配置&quot;&gt;&lt;/a&gt;整站配置&lt;/h1&gt;&lt;p&gt;您可以在 _config.yml 中修改大部份的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://xiao-chengang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://xiao-chengang.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 开发小技巧</title>
    <link href="http://xiao-chengang.github.io/2018/02/22/javascript-skill/"/>
    <id>http://xiao-chengang.github.io/2018/02/22/javascript-skill/</id>
    <published>2018-02-22T08:04:05.000Z</published>
    <updated>2018-03-20T12:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-开发小技巧"><a href="#JavaScript-开发小技巧" class="headerlink" title="JavaScript 开发小技巧"></a>JavaScript 开发小技巧</h1><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>下面是一个很好的例子，将一个完整的 if 语句，简写为一行代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">let</span> answer  </span><br><span class="line"><span class="keyword">if</span> (x&gt;<span class="number">10</span>)&#123;</span><br><span class="line">    answer=<span class="string">"greater than 10"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    answer=<span class="string">"less than 10"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以简写为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> answer =x&gt;<span class="number">10</span>?<span class="string">"greater than 10"</span>:<span class="string">"less than 10"</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>当使用纯JavaScript（不依赖外部库，如 jQuery 或lodash）时，下面的简写会非常有用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; array.length ;i++)</span><br></pre></td></tr></table></figure></p><p>可以简写为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> array)</span><br></pre></td></tr></table></figure></p><p>下面是遍历数组forEach 的简写示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>].forEach(<span class="function">(<span class="params">element,index,array</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`array[<span class="subst">$&#123;index&#125;</span>]=<span class="subst">$&#123;element&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line">logs:</span><br><span class="line">array[<span class="number">0</span>]=<span class="number">11</span></span><br><span class="line">array[<span class="number">1</span>]=<span class="number">22</span></span><br><span class="line">array[<span class="number">2</span>]=<span class="number">33</span></span><br></pre></td></tr></table></figure></p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>在函数开始之前，对变量进行赋值是一种很好的习惯。在申明多个变量时：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">let</span> y;</span><br><span class="line"><span class="keyword">let</span> z=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>可以简写为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x,y,z=<span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><h2 id="使用-代替"><a href="#使用-代替" class="headerlink" title="使用 === 代替 =="></a>使用 === 代替 ==</h2><p>==（或者!=）做对比的时候会将进行对比的两者转换到同一类型再比较。===（或者!==）则不会，他会将进行对比的两者做类型对比和值对比，相对于 == ，=== 的对比会更加严谨。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">10</span>] == <span class="number">10</span> <span class="comment">// true</span></span><br><span class="line">[<span class="number">10</span>] === <span class="number">10</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">"10"</span> == <span class="number">10</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">"10"</span> === <span class="number">10</span> <span class="comment">// false</span></span><br><span class="line">[] == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">[] === <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">""</span> == <span class="literal">false</span> <span class="comment">// true 但是 true == "a" 是false</span></span><br><span class="line"><span class="string">""</span> === <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h2 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h2><p>在使用 if 进行基本判断时，可以省略赋值运算符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag===<span class="literal">true</span>)</span><br></pre></td></tr></table></figure></p><p>可以简写为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag)</span><br></pre></td></tr></table></figure></p><h2 id="十进制数"><a href="#十进制数" class="headerlink" title="十进制数"></a>十进制数</h2><p>可以使用科学计数法来代替较大的数据，如可以将 10000000 简写为 1e7。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i=<span class="number">10000000</span>;</span><br></pre></td></tr></table></figure></p><p>可以简写为:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i=<span class="number">1e7</span>;</span><br></pre></td></tr></table></figure></p><h2 id="模版字符串（ES5以下不支持）"><a href="#模版字符串（ES5以下不支持）" class="headerlink" title="模版字符串（ES5以下不支持）"></a>模版字符串（ES5以下不支持）</h2><p>传统的JavaScript语言，输出模板通常是这样写的，字符串拼接很让人头疼，也很容易出错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(</span><br><span class="line">  <span class="string">'There are &lt;b&gt;'</span> + basket.count + <span class="string">'&lt;/b&gt; '</span> +</span><br><span class="line">  <span class="string">'items in your basket, '</span> +</span><br><span class="line">  <span class="string">'&lt;em&gt;'</span> + basket.onSale +</span><br><span class="line">  <span class="string">'&lt;/em&gt; are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>ES6引入了模板字符串解决这个问题<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#result'</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  There are &lt;b&gt;<span class="subst">$&#123;basket.count&#125;</span>&lt;/b&gt; items</span></span><br><span class="line"><span class="string">   in your basket, &lt;em&gt;<span class="subst">$&#123;basket.onSale&#125;</span>&lt;/em&gt;</span></span><br><span class="line"><span class="string">  are on sale!</span></span><br><span class="line"><span class="string">`</span>);</span><br></pre></td></tr></table></figure></p><h2 id="转换数值的更加的方法"><a href="#转换数值的更加的方法" class="headerlink" title="转换数值的更加的方法"></a>转换数值的更加的方法</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i =<span class="string">"1234"</span></span><br><span class="line">i = + str; <span class="comment">// i=1234</span></span><br></pre></td></tr></table></figure><h2 id="清空一个数组"><a href="#清空一个数组" class="headerlink" title="清空一个数组"></a>清空一个数组</h2><p>你定义一个数组，并希望清空它的内容。通常，你会这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//清空数组</span></span><br><span class="line">    list = [];</span><br><span class="line">&#125;</span><br><span class="line">empty();</span><br></pre></td></tr></table></figure></p><p>但是还有一种更高性能的方法。<br>你可以使用这些代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">empty</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//清空数组</span></span><br><span class="line">    list.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">empty();</span><br></pre></td></tr></table></figure></p><p>· list =[] 将一个变量指定个引用到那个数组，而其他引用都不受影响。这意味着，对于先前数组的内容的引用仍然保留在内存中，从而导致内存泄漏。<br>· list.length = 0 删除数组内的所有东西，这不需要引用任何其他的东西<br>然而，如果你有一个copy的数组（A和copy-A），如果你使用list.length = 0 删除其内容，副本也会失去它的内容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> bar = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> foo2 = foo;</span><br><span class="line"><span class="keyword">var</span> bar2 = bar;</span><br><span class="line">foo = [];</span><br><span class="line">bar.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo, bar, foo2, bar2);</span><br><span class="line"><span class="comment">//[] [] [1, 2, 3] []</span></span><br></pre></td></tr></table></figure></p><p>StackOverflow上的更多详情：difference-between-array-length-0-and-array</p><h2 id="对数组排序进行”洗牌”-随机排序"><a href="#对数组排序进行”洗牌”-随机排序" class="headerlink" title="对数组排序进行”洗牌”(随机排序)"></a>对数组排序进行”洗牌”(随机排序)</h2><p>这段代码在这里使用Fisher Yates洗牌算法给一个指定的数组进行洗牌(随机排序)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = array.length, i;</span><br><span class="line">    <span class="comment">// 如果还有剩余的需要打乱的元素...</span></span><br><span class="line">    <span class="keyword">while</span> (m) &#123;</span><br><span class="line">        <span class="comment">// 选择一个剩余的元素</span></span><br><span class="line">        i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * m--);</span><br><span class="line">        <span class="comment">// 和当前元素交换</span></span><br><span class="line">        [array[i],array[m]]=[array[m],array[i]]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>案例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(shuffle([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>]));</span><br><span class="line"><span class="comment">//[2, 3, 5, 4, 1, 6, 11, 9, 7, 8, 10]</span></span><br></pre></td></tr></table></figure></p><h2 id="在数组插入一个元素"><a href="#在数组插入一个元素" class="headerlink" title="在数组插入一个元素"></a>在数组插入一个元素</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">arr.push(<span class="number">6</span>); <span class="comment">// [1, 2, 4, 5, 6]</span></span><br><span class="line">arr.unshift(<span class="number">0</span>); <span class="comment">// [0, 1, 2, 4, 5, 6]</span></span><br><span class="line">arr.splice(<span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>); <span class="comment">// [0, 1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><h2 id="字符排序"><a href="#字符排序" class="headerlink" title="字符排序"></a>字符排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Shanghai'</span>, <span class="string">'New York'</span>, <span class="string">'Mumbai'</span>, <span class="string">'Buenos Aires'</span>].sort();</span><br><span class="line"><span class="comment">// ["Buenos Aires", "Mumbai", "New York", "Shanghai"]</span></span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = arr.length, j;</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                [arr[j],arr[j + <span class="number">1</span>]]=[arr[j+<span class="number">1</span>],arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="undefined-和-null-的不同"><a href="#undefined-和-null-的不同" class="headerlink" title="undefined 和 null 的不同"></a>undefined 和 null 的不同</h2><ul><li>undefined指的是一个变量未被声明，或者一个变量被声明但未赋值</li><li>null是指一个特定的值，即”没有值”</li><li>JavaScript给未赋值的变量默认定义为undefined</li><li>JavaScript不会给未赋值的变量设置null值，它被程序员用来表示一个无价值的值</li><li>undefined在json格式数据中是无效的，而null有效</li><li>undefined 类型是 undefined</li><li>null类似是object.为什么呢？</li><li>两者都是原始值</li><li>两者都被认为false(Boolean(undefined) // false, Boolean(null) // false)。</li><li>辨认变量是不是undefined<br>typeof variable === “undefined” </li><li>检查变量是不是null<br>variable === “null”<br>从值考虑他们是相等的，但是从类型和值共同考虑他们是不相等的<br>null == undefined // true<br>null === undefined // false <h2 id="严格模式”use-strict”"><a href="#严格模式”use-strict”" class="headerlink" title="严格模式”use strict”"></a>严格模式”use strict”</h2>严格模式的JavaScript让开发人员更加安全的编写JavaScript。<br>默认情况下，JavaScript允许开发者懒惰，例如，我们在第一次声明变量的时候可以不用var，虽然这可能看起来像一个没有经验的开发人员，同时这也是很多错误的根源，变量名拼写错误或意外地将它提到了外部作用域。<br>程序员喜欢让电脑为我们做些无聊的事，检查一些我们工作的错误。”use strict”指令我们做这些，将我们的错误转换成JavaScript的错误。<br>我们把这个指令可以通过添加在一个js文件的顶部：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整个script文件都将是严格模式语法</span></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="keyword">var</span> v = <span class="string">"Hi! I'm a strict mode script!"</span>;</span><br><span class="line">或者在函数内：</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 函数范围内的严格模式语法</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nested</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"And so am I!"</span>; &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hi! I'm a strict mode function! "</span> + nested();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">"I'm not strict."</span>; &#125;</span><br></pre></td></tr></table></figure></li></ul><p>在包含这个指令的JavaScript文件或者函数内，我们将一些较大的JavaScript项目中的不良行为直接在JavaScript引擎执行中禁止了。在其他情况中，严格模式改变以下的行为：</p><ul><li>变量只有在前面 var 声明了才能用</li><li>试图写入只读属性产生的误差</li><li>必须用 new 关键字调用构造函数</li><li>this 不会默认指向全局对象</li><li>非常有限的使用eval()</li><li>保护保留字符或未来保留字符不被作为变量名使用<br>严格模式在新项目中是很有好处的，但是在大多数地方没使用到它的老项目里使用它是非常具有挑战性的。当你把多个文件合并到一个文件时，它也是个问题，就像可能导致整个文件都在严格模式下执行。<br>它不是一个声明，只是一个字面量，早期版本的浏览器会忽略它。严格模式支持：</li><li>IE 10+</li><li>FF 4+</li><li>Chrome 13+</li><li>Safari 5.1+</li><li>Opera 12+<h2 id="检查一个对象是否有属性"><a href="#检查一个对象是否有属性" class="headerlink" title="检查一个对象是否有属性"></a>检查一个对象是否有属性</h2>当你要检查一个对象是否存在某个属性时，你可能会这样做 ：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">name</span>: <span class="string">'@tips_js'</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (myObject.name) &#123; ... &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这是可以的，但你必须知道这个还有两原生的方式，in operator 和 object.hasownproperty，每个对象是对象，既可用方法。每个object都继承自Object，这两个方法都可用。<br>两个方法的一些不同点：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myObject = &#123;<span class="attr">name</span>: <span class="string">'@tips_js'</span>&#125;;</span><br><span class="line">myObject.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">'name'</span> <span class="keyword">in</span> myObject; <span class="comment">// true</span></span><br><span class="line">myObject.hasOwnProperty(<span class="string">'valueOf'</span>); <span class="comment">// false, valueOf 是从原型链继承的</span></span><br><span class="line"><span class="string">'valueOf'</span> <span class="keyword">in</span> myObject; <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>他们之间的不同在于检查的性质，换句话说，当该对象本身有查找的属性时hasOwnProperty返回yrue，然而，in operator不区分属性创建的对象和属性继承的原型链。<br>这里有另外一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myFunc = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'@tips_js'</span>;</span><br><span class="line">&#125;;</span><br><span class="line">myFunc.prototype.age = <span class="string">'10 days'</span>;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> myFunc();</span><br><span class="line">user.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></span><br><span class="line">user.hasOwnProperty(<span class="string">'age'</span>); <span class="comment">// false, 因为age是原型链上的</span></span><br></pre></td></tr></table></figure></p><h2 id="ES6中参数处理"><a href="#ES6中参数处理" class="headerlink" title="ES6中参数处理"></a>ES6中参数处理</h2><p>在许多编程语言中，函数的参数是默认的，而开发人员必须显式定义一个参数是可选的。在JavaScript中的每个参数是可选的，但我们可以这一行为而不让一个函数利用ES6的默认值作为参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _err = <span class="function"><span class="keyword">function</span>(<span class="params"> message </span>)</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( message );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getSum = <span class="function">(<span class="params">a = _err(<span class="string">'a is not defined'</span></span>), <span class="params">b</span> = <span class="params">_err</span>(<span class="params"><span class="string">'b is not defined'</span></span>)) =&gt;</span> a + b</span><br><span class="line">getSum( <span class="number">10</span> ) <span class="comment">// throws Error, b is not defined</span></span><br><span class="line">getSum( <span class="literal">undefined</span>, <span class="number">10</span> ) <span class="comment">// throws Error, a is not defined</span></span><br></pre></td></tr></table></figure></p><blockquote><p>_err是立即抛出一个错误的函数。如果没有一个参数作为值，默认值是会被使用，_err将被调用，将抛出错误。你可以在Mozilla开发者网络看到的更多默认参数的例子。</p></blockquote><h2 id="测量一个JavaScript代码块性能的技巧"><a href="#测量一个JavaScript代码块性能的技巧" class="headerlink" title="测量一个JavaScript代码块性能的技巧"></a>测量一个JavaScript代码块性能的技巧</h2><p>快速测量一个JavaScript块的性能，我们可以使用控制台的功能像console.time(label)和console.timeEnd(label)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">"Array initialize"</span>);</span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000</span>),</span><br><span class="line">len = arr.length,</span><br><span class="line">i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">arr[i] = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">"Array initialize"</span>); <span class="comment">// 输出: Array initialize: 0.451904296875ms</span></span><br></pre></td></tr></table></figure></p><p>更多信息Console object, JavaScript benchmarking<br>demo：jsfiddle-codepen (在浏览器控制台输出)</p><h2 id="arrow-函数-ES6"><a href="#arrow-函数-ES6" class="headerlink" title="arrow 函数(ES6)"></a>arrow 函数(ES6)</h2><p>介绍下ES6里的新功能，arrow函数可能会是个很方便的工具，用更少行数写更多代码。他的名字来源于他的语法，=&gt;和小箭头-&gt;比就像一个“胖胖的箭头”。可能有些人知道，这种函数类型和其他静态语言如lambda表达式的匿名函数。它被称为匿名，因为这些箭头函数没有一个描述性的函数名。<br>那么这样有什么好处呢？<br>语法：更少的LOC，不用一次次的键入函数关键字。<br>语义：从上下文中捕捉关键字this。<br>简单语法案例：<br>看看下面的两段代码片段，他们做的是一样的工作。你能很快的理解arrow函数的功能。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arrow函数的日常语法</span></span><br><span class="line">param =&gt; expression</span><br><span class="line"><span class="comment">// 可能也会写在括号中</span></span><br><span class="line"><span class="comment">// 括号是多参数要求</span></span><br><span class="line">(param1 [, param2]) =&gt; expression</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用日常函数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arrFunc = arr.map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 使用arrow函数</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> arrFunc = arr.map(<span class="function">(<span class="params">x</span>) =&gt;</span> x*x);</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure></p><p>正如你所看到的，这个例子中的arrow函数可以节省你输入括号内参数和返回关键字的时间。建议把圆括号内的参数输入，如 (x,y) =&gt; x+y 。在不同的使用情况下，它只是用来应对遗忘的一种方式。但是上面的代码也会这样执行：x =&gt; x*x.目前看来，这些仅仅是导致更少的LOC和更好的可读性的句法改进。<br>this 绑定<br>还有一个更好的理由使用arrow函数。那就是在会出现this问题的背景下。使用arrow函数，你就不用担心.bind(this)和 that=this 了。因为arrow函数会从上下文中找到this。<br>看下面的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局定义this.i</span></span><br><span class="line"><span class="keyword">this</span>.i = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> counterA = <span class="keyword">new</span> CounterA();</span><br><span class="line"><span class="keyword">var</span> counterB = <span class="keyword">new</span> CounterB();</span><br><span class="line"><span class="keyword">var</span> counterC = <span class="keyword">new</span> CounterC();</span><br><span class="line"><span class="keyword">var</span> counterD = <span class="keyword">new</span> CounterD();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 不好的示例</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// CounterA's `this` 实例 (!! 忽略这里)</span></span><br><span class="line">    <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// `this` 指全局对象，而不是 CounterA's `this`</span></span><br><span class="line">        <span class="comment">// 因此，开始计数与100，而不是0 (本地的 this.i)</span></span><br><span class="line">        <span class="keyword">this</span>.i++;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"counterA"</span>).innerHTML = <span class="keyword">this</span>.i;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 手动绑定 that = this</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        that.i++;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"counterB"</span>).innerHTML = that.i;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 .bind(this)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterC</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">    setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i++;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"counterC"</span>).innerHTML = <span class="keyword">this</span>.i;</span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>), <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 arrow函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterD</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.i = <span class="number">0</span>;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.i++;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">"counterD"</span>).innerHTML = <span class="keyword">this</span>.i;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用更简单的类似indexOf的包含判断方式"><a href="#使用更简单的类似indexOf的包含判断方式" class="headerlink" title="使用更简单的类似indexOf的包含判断方式"></a>使用更简单的类似indexOf的包含判断方式</h2><p>原生的JavaScript没有contains方法。对检查字符串或字符串数组项中是否存在某值，你可以这样做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someText = <span class="string">'JavaScript rules'</span>;</span><br><span class="line"><span class="keyword">if</span> (someText.indexOf(<span class="string">'JavaScript'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span> (someText.indexOf(<span class="string">'JavaScript'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是我们再看看这些ExpressJs代码片段。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// examples/mvc/lib/boot.js</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line"><span class="comment">// "reserved" exports</span></span><br><span class="line"><span class="keyword">if</span> (~[<span class="string">'name'</span>, <span class="string">'prefix'</span>, <span class="string">'engine'</span>, <span class="string">'before'</span>].indexOf(key)) <span class="keyword">continue</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// examples/lib/utils.js</span></span><br><span class="line">exports.normalizeType = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~type.indexOf(<span class="string">'/'</span>)</span><br><span class="line">? acceptParams(type)</span><br><span class="line">: &#123; <span class="attr">value</span>: mime.lookup(type), <span class="attr">params</span>: &#123;&#125; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// examples/web-service/index.js</span></span><br><span class="line"><span class="comment">// key is invalid</span></span><br><span class="line"><span class="keyword">if</span> (!~apiKeys.indexOf(key)) <span class="keyword">return</span> next(error(<span class="number">401</span>, <span class="string">'invalid api key'</span>));</span><br></pre></td></tr></table></figure></p><p>问题是~位运算符。”运算符执行操作这样的二进制表达式，但他们返回标准的JavaScript的数值.”<br>他们将-1转换为0，而0在JavaScript中又是false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someText = <span class="string">'text'</span>;</span><br><span class="line">!!~someText.indexOf(<span class="string">'tex'</span>); <span class="comment">// someText 包含 "tex" - true</span></span><br><span class="line">!~someText.indexOf(<span class="string">'tex'</span>); <span class="comment">// someText 不包含 "tex" - false</span></span><br><span class="line">~someText.indexOf(<span class="string">'asd'</span>); <span class="comment">// someText 不包含 "asd" - false</span></span><br><span class="line">~someText.indexOf(<span class="string">'ext'</span>); <span class="comment">// someText 包含 "ext" - true</span></span><br><span class="line"><span class="built_in">String</span>.prototype.includes()</span><br></pre></td></tr></table></figure></p><p>在ES6(ES 2015)中介绍了includes()方法可以用来确定是否一个字符串包含另一个字符串：<br>‘something’.includes(‘thing’); // true<br>在ECMAScript 2016 (ES7)中，甚至数组都可以这样操作，如indexOf：<br>!!~[1, 2, 3].indexOf(1); // true<br>[1, 2, 3].includes(1); // true<br>不幸的是，这只是在Chrome，Firefox，Safari 9或以上的浏览器中被支持。</p><h2 id="给回调函数传递参数"><a href="#给回调函数传递参数" class="headerlink" title="给回调函数传递参数"></a>给回调函数传递参数</h2><p>在默认情况下，你无法将参数传给回调函数，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi human'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'someelem'</span>).addEventListener(<span class="string">'click'</span>, callback);</span><br></pre></td></tr></table></figure></p><p>你可以采取JavaScript闭包的优点来给回调函数传参，案例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sum = '</span>, (a+b));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'someelem'</span>).addEventListener(<span class="string">'click'</span>, callback(x, y));</span><br></pre></td></tr></table></figure></p><p>什么是闭包呢？闭包是指一个针对独立的(自由)变量的函数。换句话说，闭包中定义的函数会记住它被创建的环境。了解更多请参阅MDN所以这种方式当被调用的时候，参数X/Y存在于回调函数的作用域内。<br>另一种方法是使用绑定方法。例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alertText = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">alert(text);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'someelem'</span>).addEventListener(<span class="string">'click'</span>, alertText.bind(<span class="keyword">this</span>, <span class="string">'hello'</span>));</span><br></pre></td></tr></table></figure></p><p>两种方法在性能上有一些略微区别，详情参阅jsperf</p><h2 id="Node-js-让module在没被require的时候运行"><a href="#Node-js-让module在没被require的时候运行" class="headerlink" title="Node.js:让module在没被require的时候运行"></a>Node.js:让module在没被require的时候运行</h2><p>在node里，你可以根据代码是运行了require(‘./something.js’)还是node something.js，来告诉你的程序去做两件不同的事情。如果你想与你的一个独立的模块进行交互，这是很有用的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">module</span>.parent) &#123;</span><br><span class="line">    <span class="comment">// 运行 `node something.js`</span></span><br><span class="line">    app.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 `require('/.something.js')`</span></span><br><span class="line">    <span class="built_in">module</span>.exports = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>更多信息，请看the documentation for modules</p><h2 id="更快的四舍五入"><a href="#更快的四舍五入" class="headerlink" title="更快的四舍五入"></a>更快的四舍五入</h2><p>今天的技巧是关于性能。见到过双波浪线”~~”操作符吗？它有时也被称为double NOT运算符。你可以更快的使用它来作为Math.floor()替代品。为什么呢？<br>单位移~将32位转换输入-(输入+1)，因此双位移将输入转换为-(-(输入+1))，这是个趋于0的伟大的工具。对于输入的数字，它将模仿Math.ceil()取负值和Math.floor()取正值。如果执行失败，则返回0，这可能在用来代替Math.floor()失败时返回一个NaN的时候发挥作用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单位移</span></span><br><span class="line"><span class="built_in">console</span>.log(~<span class="number">1337</span>) <span class="comment">// -1338</span></span><br><span class="line"><span class="comment">// 双位移</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">47.11</span>) <span class="comment">// -&gt; 47</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">-12.88</span>) <span class="comment">// -&gt; -12</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">1.9999</span>) <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="number">3</span>) <span class="comment">// -&gt; 3</span></span><br><span class="line"><span class="comment">//失败的情况</span></span><br><span class="line"><span class="built_in">console</span>.log(~~[]) <span class="comment">// -&gt; 0 </span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="literal">NaN</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">console</span>.log(~~<span class="literal">null</span>) <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="comment">//大于32位整数则失败</span></span><br><span class="line"><span class="built_in">console</span>.log(~~(<span class="number">2147483647</span> + <span class="number">1</span>) === (<span class="number">2147483647</span> + <span class="number">1</span>)) <span class="comment">// -&gt; 0</span></span><br></pre></td></tr></table></figure></p><p>虽然~~可能有更好的表现，为了可读性，请使用Math.floor()。</p><h2 id="字符串安全连接"><a href="#字符串安全连接" class="headerlink" title="字符串安全连接"></a>字符串安全连接</h2><p>假设你有一些类型未知的变量，你想将它们连接起来。可以肯定的是，算法操作不会在级联时应用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> two = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> three = <span class="string">'3'</span>;</span><br><span class="line"><span class="keyword">var</span> result = one + two + three; <span class="comment">//"33" 而不是 "123"</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>+one + two + three; <span class="comment">//"123"</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="string">''</span>.concat(one, two, three); <span class="comment">//"123"</span></span><br></pre></td></tr></table></figure></p><h2 id="返回对象的函数能够用于链式操作"><a href="#返回对象的函数能够用于链式操作" class="headerlink" title="返回对象的函数能够用于链式操作"></a>返回对象的函数能够用于链式操作</h2><p>当创建面向对象的JavaScript对象的function时，函数返回一个对象将能够让函数可链式的写在一起来执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Hello my name is: "</span>, <span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">this</span>.changeName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"John"</span>);</span><br><span class="line">person.sayName().changeName(<span class="string">"Timmy"</span>).sayName();</span><br><span class="line"><span class="comment">//Hello my name is: John</span></span><br><span class="line"><span class="comment">//Hello my name is: Timmy</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JavaScript-开发小技巧&quot;&gt;&lt;a href=&quot;#JavaScript-开发小技巧&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 开发小技巧&quot;&gt;&lt;/a&gt;JavaScript 开发小技巧&lt;/h1&gt;&lt;h2 id=&quot;三目运算符&quot;&gt;&lt;a href=&quot;#三目运算符&quot; class=&quot;headerlink&quot; title=&quot;三目运算符&quot;&gt;&lt;/a&gt;三目运算符&lt;/h2&gt;&lt;p&gt;下面是一个很好的例子，将一个完整的 if 语句，简写为一行代码。&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; x=&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; answer  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (x&amp;gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    answer=&lt;span class=&quot;string&quot;&gt;&quot;greater than 10&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    answer=&lt;span class=&quot;string&quot;&gt;&quot;less than 10&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以简写为:&lt;br&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; answer =x&amp;gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;?&lt;span class=&quot;string&quot;&gt;&quot;greater than 10&quot;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;less than 10&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://xiao-chengang.github.io/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://xiao-chengang.github.io/tags/JavaScript/"/>
    
      <category term="tips" scheme="http://xiao-chengang.github.io/tags/tips/"/>
    
  </entry>
  
  <entry>
    <title>Hexo搭建GitHub博客</title>
    <link href="http://xiao-chengang.github.io/2018/02/20/create-hexo/"/>
    <id>http://xiao-chengang.github.io/2018/02/20/create-hexo/</id>
    <published>2018-02-20T02:55:19.000Z</published>
    <updated>2018-02-26T08:28:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<br><a id="more"></a></p><h1 id="基础配置篇"><a href="#基础配置篇" class="headerlink" title="基础配置篇"></a>基础配置篇</h1><p><strong>【注：本文中使用的 Hexo 版本为3.22，部分配置与2.x可能有所出入】</strong></p><ol><li>安装 &amp; 搭建</li></ol><ul><li>安装Git：安装后，注册 Github 账号，配置 SSH（具体见下一步）,打开 Git Bash,- 接下来的命令均在Git Bash中执行</li><li>安装Node.js</li><li>安装 Hexo : $npm install -g hexo</li><li>安装依赖包： $npm install</li><li>新建博客文件夹：cd到该文件夹，执行$hexo init</li><li>新建Github仓库：仓库名必须为你的Github名.github.io，要不然就不能使用Github Pages服务了。。。</li></ul><hr><ol><li><p>配置 SSH</p><p> 关于什么是 SSH，请自行百度（我懒..）这里直接讲一下配置步骤。</p></li></ol><ul><li><p>本地生成公钥私钥 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　$ssh-keygen -t rsa -C &quot;你的邮件地址&quot;</span><br></pre></td></tr></table></figure></li><li><p>添加公钥到 Github </p><ul><li>根据上一步的提示，找到公钥文件（默认为id_rsa.pub），用记事本打开，全选并复制。</li><li>登录 Github，右上角 头像 -&gt; Settings —&gt; SSH keys —&gt; Add SSH key。把公钥粘贴到key中，填好title并点击 Add key。</li><li>git bash中输入命令$ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>，选yes，等待片刻可看到成功提示。</li></ul></li></ul><hr><ol><li>NexT主题下载<br> NexT 主题是由 iissnan 大神所制作的一款简洁美观不失逼格的主题。下载方法有以下两种：</li></ol><ul><li><p>进入博客根目录<code>/themes/</code>, 执行<code>$git clone</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/iissnan/hexo-theme-next.git</span><br></pre></td></tr></table></figure></li><li><p>直接进入上面的链接，在项目主页download zip文件，然后解压到<code>博客根目录/themes/</code>文件夹</p></li></ul><hr><ol><li>发布<br> 使用以下两条命令进行发布，发布成功后可在浏览器中使用你的github名.github.io进入你的博客~<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$hexo clean</span><br><span class="line">$hexo d -g</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="Hexo日常使用篇"><a href="#Hexo日常使用篇" class="headerlink" title="Hexo日常使用篇"></a>Hexo日常使用篇</h1><ol><li><p>生成静态页面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure></li><li><p>本地预览：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$hexo server//或 hexo s</span><br><span class="line">//然后打开浏览器输入localhost:4000可以预览博客效果，用于调试</span><br></pre></td></tr></table></figure></li><li><p>新建文章</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$hexo new post &quot;title&quot;</span><br><span class="line">//新文章位置：/source/_posts</span><br></pre></td></tr></table></figure></li><li><p>新建页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo new page &quot;title&quot;</span><br></pre></td></tr></table></figure></li><li><p>部署并生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo d -g</span><br></pre></td></tr></table></figure></li><li><p>清除生成的文件和缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$hexo clean</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="config文件配置篇"><a href="#config文件配置篇" class="headerlink" title="_config文件配置篇"></a>_config文件配置篇</h1><h2 id="1-整站配置"><a href="#1-整站配置" class="headerlink" title="1.整站配置"></a>1.整站配置</h2><p>请参照<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">hexo官网配置</a></p><h2 id="2-Next主题配置"><a href="#2-Next主题配置" class="headerlink" title="2.Next主题配置"></a>2.Next主题配置</h2><p>请参照<a href="http://theme-next.iissnan.com/theme-settings.html#tags-page" target="_blank" rel="noopener">next主题配置</a></p><h1 id="个人定制模块"><a href="#个人定制模块" class="headerlink" title="个人定制模块"></a>个人定制模块</h1><h2 id="更改代码块颜色及字体大小"><a href="#更改代码块颜色及字体大小" class="headerlink" title="更改代码块颜色及字体大小"></a>更改代码块颜色及字体大小</h2><ol><li>打开\themes\next\source\css\ _variables\base.styl文件</li><li>修改$code-background和$code-foreground的值：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// Code &amp; Code Blocks</span><br><span class="line">// 用``围出的代码块</span><br><span class="line">// --------------------------------------------------</span><br><span class="line">$code-font-family               = $font-family-monospace</span><br><span class="line">$code-font-size                 = 15px # 代码字体大小</span><br><span class="line">$code-background                = #自定义RGB值</span><br><span class="line">$code-foreground                = #自定义RGB值</span><br><span class="line">$code-border-radius             = 4px</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hexo简介&quot;&gt;&lt;a href=&quot;#Hexo简介&quot; class=&quot;headerlink&quot; title=&quot;Hexo简介&quot;&gt;&lt;/a&gt;Hexo简介&lt;/h1&gt;&lt;p&gt;Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://xiao-chengang.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://xiao-chengang.github.io/tags/hexo/"/>
    
      <category term="blog" scheme="http://xiao-chengang.github.io/tags/blog/"/>
    
      <category term="教程" scheme="http://xiao-chengang.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Mac终端使用技巧 切换到其他路径和目录</title>
    <link href="http://xiao-chengang.github.io/2018/02/18/terminal/"/>
    <id>http://xiao-chengang.github.io/2018/02/18/terminal/</id>
    <published>2018-02-18T07:09:47.000Z</published>
    <updated>2018-02-26T07:32:25.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如果你想将当前 command line 会话切换到其他目录，需要用到三个命令：pwd，ls和cd。</strong><br><strong>pwd的含义是“print working directory”，会显示当前目录的绝对路径。</strong><br><strong>ls的含义是“list directory contents”，它会列出当前目录的内容。这个命令还有其他参数可选。</strong><br><strong>cd的含义是“change directory”，它会改变当前目录到你指定的目录。如果你不指定，则会返回你的 home folder。</strong><br><a id="more"></a></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>pwd　　　　　　当前工作目录</p><p>cd（不加参数）　　进root</p><p>cd（folder）　　进入文件夹</p><p>cd ..　　　　　　上级目录</p><p>cd ~　　　　　　返回root</p><p>cd -　　　　　　返回上一个访问的目录</p><p>rm 文件名 　　　　删除</p><p>cat 文件名(|less)　　在终端下查看文件</p><p>ls　　　　　　　　列出目录下所有文件</p><p>cp 文件名 目标目录　　将文件拷贝到目标目录下</p><p>~代表root　　如：~/Document/CPP2/</p><p>mkdiv　　　　　　新建文件夹</p><p>g++ 源文件名　　　　编译源文件，产生a.out</p><p>./文件名　　　　　　运行  例如：./a.out &lt; 输入文件名 &gt; 输出文件名</p><p>control+d　　　　　中断a.out运行</p><p>nano 　　　　　　编写脚本语言　　ctrl+o存储</p><p>nano ….sh　　　　打开</p><p>bash ….sh　　　　运行脚本</p><p>echo “…$i…”　　　输出语句</p><p>tar -zxf abc.tar.gz     tar文件解压</p><p>ssh <a href="mailto:root@192.168.1.222" target="_blank" rel="noopener">root@192.168.1.222</a>   以root账号远程连接222服务器<br>unrar x abc.rar     rar文件解压，需要安装rar工具</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;如果你想将当前 command line 会话切换到其他目录，需要用到三个命令：pwd，ls和cd。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;pwd的含义是“print working directory”，会显示当前目录的绝对路径。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;ls的含义是“list directory contents”，它会列出当前目录的内容。这个命令还有其他参数可选。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;cd的含义是“change directory”，它会改变当前目录到你指定的目录。如果你不指定，则会返回你的 home folder。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="terminal" scheme="http://xiao-chengang.github.io/categories/terminal/"/>
    
    
      <category term="mac" scheme="http://xiao-chengang.github.io/tags/mac/"/>
    
      <category term="terminal" scheme="http://xiao-chengang.github.io/tags/terminal/"/>
    
      <category term="快捷键" scheme="http://xiao-chengang.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>angular 初探</title>
    <link href="http://xiao-chengang.github.io/2018/02/16/angular/"/>
    <id>http://xiao-chengang.github.io/2018/02/16/angular/</id>
    <published>2018-02-16T07:09:47.000Z</published>
    <updated>2018-03-20T12:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><ol><li>安装cnpm <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li></ol><a id="more"></a><ol><li>安装angular</li></ol><ul><li>用cnpm安装@angular/cli<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @angular/cli</span><br><span class="line"></span><br><span class="line">cnpm install -g @angular/cli</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>这个CLI是Command Line Interface的简写，是一种命令行接口，实现自动化开发流程.它可以创建项目、添加文件以及执行一大堆开发任务，比如测试、打包和发布。  </p><ul><li>检查版本。输入 ng -v，出现下面的效果，就证明你安装@angluar/cli 成功了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng -v</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li>安装失败时<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g @angular/cli  //卸载angular/cli </span><br><span class="line"></span><br><span class="line">npm cache clean  //清除缓存</span><br><span class="line"></span><br><span class="line">cnpm install -g @angular/cli //重新安装</span><br></pre></td></tr></table></figure></li></ul><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>先到cmd里进入项目所在的目录，用cd命令进入。</p><ol><li><p>新建项目名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng new your_project</span><br></pre></td></tr></table></figure></li><li><p>进入所建目录启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd your_project</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install     //安装依赖</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng serve --open  //启动服务</span><br></pre></td></tr></table></figure><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><p>Angualr CLI提供了许多常用命令供我们选择：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ng generate class my-new-class              // 新建 class</span><br><span class="line">ng g cl my-new-class                        // 新建 class</span><br><span class="line">ng generate component my-new-component      // 新建组件</span><br><span class="line">ng g c my-new-component                     // 新建组件</span><br><span class="line">ng generate directive my-new-directive      // 新建指令</span><br><span class="line">ng g d my-new-directive                     // 新建指令</span><br><span class="line">ng generate enum my-new-enum                // 新建枚举</span><br><span class="line">ng g e my-new-enum                          // 新建枚举</span><br><span class="line">ng generate module my-new-module            // 新建模块</span><br><span class="line">ng g m my-new-module                        // 新建模块</span><br><span class="line">ng generate pipe my-new-pipe                // 新建管道</span><br><span class="line">ng g p my-new-pipe                          // 新建管道</span><br><span class="line">ng generate service my-new-service          // 新建服务</span><br><span class="line">ng g s my-new-service                       // 新建服务</span><br></pre></td></tr></table></figure></p><h1 id="构建应用程序"><a href="#构建应用程序" class="headerlink" title="构建应用程序"></a>构建应用程序</h1><p>若要构建应用程序，则可以运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ng build</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;安装cnpm &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install cnpm -g --registry=https://registry.npm.taobao.org&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="angular" scheme="http://xiao-chengang.github.io/categories/angular/"/>
    
    
      <category term="angular" scheme="http://xiao-chengang.github.io/tags/angular/"/>
    
  </entry>
  
  <entry>
    <title>Fisher–Yates Shuffle洗牌算法</title>
    <link href="http://xiao-chengang.github.io/2018/01/21/Yates%20Shuffle/"/>
    <id>http://xiao-chengang.github.io/2018/01/21/Yates Shuffle/</id>
    <published>2018-01-21T07:36:04.000Z</published>
    <updated>2018-03-20T12:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fisher–Yates-Shuffle洗牌算法"><a href="#Fisher–Yates-Shuffle洗牌算法" class="headerlink" title="Fisher–Yates Shuffle洗牌算法"></a>Fisher–Yates Shuffle洗牌算法</h1><p>如果你想跟朋友一起玩德州扑克的话，你应该先洗牌，以随机的牌序来确保一个公平的游戏。但是怎么做呢？</p><p>有一个简单而有效的做法就是把牌随机选一叠放到另一边，形成一个新的牌堆，并且重复这一步。只要你从剩余的牌堆中随机选出来的牌的概率是相等的，那么你就会得到一个完美且公平的牌堆。如图1所示(<strong>译注：为了不影响阅读，我把gif图都放到了文章末尾</strong>)。</p><p>假设这不是一副实体的牌，你可能想写一段代码，用内存中的n个元素来做同样的事情。听起来很简单(某种程度上)，但你如何从最初的牌堆中精确的选择一个随机的剩余的元素？<br><a id="more"></a><br>有一个很慢的方法：从开始的地方，在数组中(在[0, n - 1]中)选择一个随机的元素，然后判断是否已经是被打乱了。这个方法可以运行，但是随着剩余元素的减少会变得越来越慢，你会一直选择已经被打乱的元素。观察那些导致洗牌变慢的重复的选择（红色）。如图2所示。</p><p>这里有一段用JavaScript实现的代码，但是你不应该使用它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = [], n = array.length, i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还有剩余的需要打乱的元素...</span></span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择一个剩余的元素</span></span><br><span class="line">    i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * array.length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经打乱，把它移动到新的数组</span></span><br><span class="line">    <span class="keyword">if</span> (i <span class="keyword">in</span> array) &#123;</span><br><span class="line">      copy.push(array[i]);</span><br><span class="line">      <span class="keyword">delete</span> array[i];</span><br><span class="line">      n--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现是不好的，我们能够做的更好。你可以只选择剩余的元素，避免重复选择。在[0, m - 1]之间选择一个随机数，在每一次循环后，m也会随着n的递减而递减。换句话说，m指的是需要打乱的剩余的元素。当你移动卡牌的时候并且合并剩余的牌，因此你能够很容易的选出下一张要洗的牌。如图3所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = [], n = array.length, i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还有剩余的需要打乱的元素...</span></span><br><span class="line">  <span class="keyword">while</span> (n) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择一个剩余的元素</span></span><br><span class="line">    i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * n--);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把它移动到新的数组</span></span><br><span class="line">    copy.push(array.splice(i, <span class="number">1</span>)[<span class="number">0</span>]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序运行的非常好，但是还能再次优化性能。主要的问题是当你从原始数组中移动每个元素(array.splice)，你不得不移动该元素后续的所有元素，平均来说，打乱每个元素需要移动n/2个元素。复杂度是 O(n<sup>2</sup>)</p><p>但是有一个非常有意思的地方，如果你认真的观察：每一个被打乱过的元素的数量(n - m)加上剩余的元素的数量(m)会一直等于总长度n。这意味着我们可以原地洗牌，不需要额外的空间！我们在数组的后面的部分存储打乱过的元素，在数组的前面的部分存储剩余的元素。我们不需要关心剩余元素的顺序，只要我们在选择的时候样本一致！</p><p>为了实现这个O(n)复杂度的原地洗牌算法，随机选择一个剩余的元素(从数组的前面)，然后放在新的位置(数组的后面)，还未被打乱的元素交换到数组前面，如图4所示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shuffle</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = array.length, t, i;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果还有剩余的需要打乱的元素...</span></span><br><span class="line">  <span class="keyword">while</span> (m) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择一个剩余的元素</span></span><br><span class="line">    i = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * m--);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 和当前元素交换</span></span><br><span class="line">    [array[i],array[m]]=[array[m],array[i]]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多的关于Fisher–Yates shuffle内容请看<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" target="_blank" rel="noopener">Wikipedia article</a>和Jeff Atwood的文章<a href="http://www.codinghorror.com/blog/2007/12/the-danger-of-naivete.html" target="_blank" rel="noopener">The Danger of Naïveté</a>。</p><hr><p>图1</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://7xo525.com1.z0.glb.clouddn.com/demo1.gif" alt="demo1.gif"></h2><p>图2</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="http://7xo525.com1.z0.glb.clouddn.com/demo2.gif" alt="demo2.gif"></h2><p>图3</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="http://7xo525.com1.z0.glb.clouddn.com/demo3.gif" alt="demo3.gif"></h2><p>图4<br><img src="http://7xo525.com1.z0.glb.clouddn.com/demo4.gif" alt="demo4.gif"></p><blockquote><p>原文地址 <a href="https://bost.ocks.org/mike/shuffle/" target="_blank" rel="noopener">Fisher–Yates Shuffle</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Fisher–Yates-Shuffle洗牌算法&quot;&gt;&lt;a href=&quot;#Fisher–Yates-Shuffle洗牌算法&quot; class=&quot;headerlink&quot; title=&quot;Fisher–Yates Shuffle洗牌算法&quot;&gt;&lt;/a&gt;Fisher–Yates Shuffle洗牌算法&lt;/h1&gt;&lt;p&gt;如果你想跟朋友一起玩德州扑克的话，你应该先洗牌，以随机的牌序来确保一个公平的游戏。但是怎么做呢？&lt;/p&gt;
&lt;p&gt;有一个简单而有效的做法就是把牌随机选一叠放到另一边，形成一个新的牌堆，并且重复这一步。只要你从剩余的牌堆中随机选出来的牌的概率是相等的，那么你就会得到一个完美且公平的牌堆。如图1所示(&lt;strong&gt;译注：为了不影响阅读，我把gif图都放到了文章末尾&lt;/strong&gt;)。&lt;/p&gt;
&lt;p&gt;假设这不是一副实体的牌，你可能想写一段代码，用内存中的n个元素来做同样的事情。听起来很简单(某种程度上)，但你如何从最初的牌堆中精确的选择一个随机的剩余的元素？&lt;br&gt;
    
    </summary>
    
      <category term="javaScript" scheme="http://xiao-chengang.github.io/categories/javaScript/"/>
    
    
      <category term="javaScript" scheme="http://xiao-chengang.github.io/tags/javaScript/"/>
    
      <category term="算法" scheme="http://xiao-chengang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>markdown常用语法</title>
    <link href="http://xiao-chengang.github.io/2018/01/19/markdown/"/>
    <id>http://xiao-chengang.github.io/2018/01/19/markdown/</id>
    <published>2018-01-19T07:36:04.000Z</published>
    <updated>2018-02-27T03:26:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。<br>注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！</p><a id="more"></a><h1 id="MarkDown的常用语法"><a href="#MarkDown的常用语法" class="headerlink" title="MarkDown的常用语法"></a>MarkDown的常用语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>Markdown 标题支持两种形式：</p><h3 id="1、用-标记"><a href="#1、用-标记" class="headerlink" title="1、用#标记"></a>1、用#标记</h3><p>在 <strong>标题开头</strong> 加上1~6个#，依次代表一级标题、二级标题….六级标题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">##### 四级标题</span><br><span class="line">###### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure></p><h3 id="2、用-和-标记"><a href="#2、用-和-标记" class="headerlink" title="2、用=和-标记"></a>2、用=和-标记</h3><p>在 <strong>标题底下</strong> 加上任意个=代表一级标题，-代表二级标题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">======</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">----------</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Markdown 支持有序列表和无序列表。</p><p><strong>无序列表使用-、+和*作为列表标记：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- Red</span><br><span class="line">- Green</span><br><span class="line">- Blue</span><br><span class="line"></span><br><span class="line">* Red</span><br><span class="line">* Green</span><br><span class="line">* Blue</span><br><span class="line"></span><br><span class="line">+ Red</span><br><span class="line">+ Green</span><br><span class="line">+ Blue</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p><strong>有序列表则使用数字加英文句点.来表示：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. Red</span><br><span class="line">2. Green</span><br><span class="line">3. Blue</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><ol><li>Red</li><li>Green</li><li>Blue</li></ol><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>引用以&gt;来表示，引用中支持多级引用、标题、列表、代码块、分割线等常规语法。</p><p>常见的引用写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这是一段引用    //在`&gt;`后面有 1 个空格</span><br><span class="line">&gt; </span><br><span class="line">&gt;     这是引用的代码块形式    //在`&gt;`后面有 5 个空格</span><br><span class="line">&gt;     </span><br><span class="line">&gt; 代码例子：</span><br><span class="line">&gt;   </span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&gt; 一级引用</span><br><span class="line">&gt; &gt; 二级引用</span><br><span class="line">&gt; &gt; &gt; 三级引用</span><br><span class="line"></span><br><span class="line">&gt; #### 这是一个四级标题</span><br><span class="line">&gt; </span><br><span class="line">&gt; 1. 这是第一行列表项</span><br><span class="line">&gt; 2. 这是第二行列表项</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><blockquote><p>这是一段引用</p><pre><code>这是引用的代码块形式    //在`&gt;`后面有 5 个空格</code></pre><p>代码例子：</p><pre><code>protected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}</code></pre></blockquote><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><blockquote><h4 id="这是一个四级标题"><a href="#这是一个四级标题" class="headerlink" title="这是一个四级标题"></a>这是一个四级标题</h4><ol><li>这是第一行列表项</li><li>这是第二行列表项</li></ol><p>以下是分割线</p><hr></blockquote><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>两个<em>或-代表加粗，一个</em>或-代表斜体，~~代表删除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**加粗文本** 或者 __加粗文本__</span><br><span class="line"></span><br><span class="line">*斜体文本*  或者_斜体文本_</span><br><span class="line"></span><br><span class="line">~~删除文本~~</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p><strong>加粗文本</strong> 或者 <strong>加粗文本</strong></p><p><em>斜体文本</em>  或者<em>斜体文本</em></p><p><del>删除文本</del></p><hr><h2 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h2><p>图片与链接的语法很像，区别在一个 ! 号。二者格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">图片：![]()    ![图片文本(可忽略)](图片地址)</span><br><span class="line"></span><br><span class="line">链接：[]()     [链接文本](链接地址)</span><br></pre></td></tr></table></figure></p><p>链接又分为<code>行内式</code>、<code>参考式</code>和 <code>自动链接</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">这是行内式链接：[码农的自我修养](https://xiao-chengang.github.io)。</span><br><span class="line"></span><br><span class="line">这是参考式链接：[码农的自我修养][url]，其中url为链接标记，可置于文中任意位置。</span><br><span class="line"></span><br><span class="line">[url]: https://xiao-chengang.github.io/ &quot;码农的自我修养&quot;</span><br><span class="line"></span><br><span class="line">链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</span><br><span class="line"></span><br><span class="line">这是自动链接：直接使用`&lt;&gt;`括起来&lt;https://xiao-chengang.github.io&gt;</span><br><span class="line"></span><br><span class="line">这是图片：![][avatar]  </span><br><span class="line">这是图片：![](/images/md.jpg)</span><br><span class="line"></span><br><span class="line">[avatar]: https://xiao-chengang.github.io/img/md.jpg</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><p>这是行内式链接：<a href="https://xiao-chengang.github.io">码农的自我修养</a>。</p><p>这是参考式链接：<a href="https://xiao-chengang.github.io/" title="码农的自我修养">码农的自我修养</a>，其中url为链接标记，可置于文中任意位置。</p><p>链接标记格式为：[链接标记文本]:  链接地址  链接title(可忽略)</p><p>这是自动链接：直接使用<code>&lt;&gt;</code>括起来<a href="https://xiao-chengang.github.io">https://xiao-chengang.github.io</a></p><p>这是图片：<img src="https://xiao-chengang.github.io/images/md.jpg" alt=""><br>这是图片：<img src="/images/md.jpg" alt="">  </p><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码分为<code>行内代码</code>和<code>代码块</code>。</p><ul><li><p>行内代码使用 <code>代码</code> 标识，可嵌入文字中</p></li><li><p>代码块使用4个空格或```标识</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里是代码</span><br></pre></td></tr></table></figure><ul><li>代码语法高亮在 ```后面加上空格和语言名称即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//注意语言前面有空格</span><br><span class="line">这里是代码</span><br></pre></td></tr></table></figure><p>效果如下：<br>这是行内代码<code>onCreate(Bundle savedInstanceState)</code>的例子。</p><p>这是代码块和语法高亮：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 注意java前面有空格</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>表格对齐格式</p><ul><li>居左：:—-</li><li>居中：:—-:或—–</li><li>居右：—-:</li></ul><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|标题|标题|标题|</span><br><span class="line">|:---|:---:|---:|</span><br><span class="line">|居左测试文本|居中测试文本|居右测试文本|</span><br><span class="line">|居左测试文本1|居中测试文本2|居右测试文本3|</span><br><span class="line">|居左测试文本11|居中测试文本22|居右测试文本33|</span><br><span class="line">|居左测试文本111|居中测试文本222|居右测试文本333|</span><br></pre></td></tr></table></figure></p><p>效果如下：</p><table><thead><tr><th style="text-align:left">标题</th><th style="text-align:center">标题</th><th style="text-align:right">标题</th></tr></thead><tbody><tr><td style="text-align:left">居左测试文本</td><td style="text-align:center">居中测试文本</td><td style="text-align:right">居右测试文本</td></tr><tr><td style="text-align:left">居左测试文本1</td><td style="text-align:center">居中测试文本2</td><td style="text-align:right">居右测试文本3</td></tr><tr><td style="text-align:left">居左测试文本11</td><td style="text-align:center">居中测试文本22</td><td style="text-align:right">居右测试文本33</td></tr><tr><td style="text-align:left">居左测试文本111</td><td style="text-align:center">居中测试文本222</td><td style="text-align:right">居右测试文本333</td></tr></tbody></table><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>在一行中用三个以上的<code>*</code>、<code>-</code>、<code>_</code>来建立一个分隔线，行内不能有其他东西。也可以在符号间插入空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br><span class="line"></span><br><span class="line">* * *</span><br></pre></td></tr></table></figure></p><p>效果均为一条分割线：</p><hr><hr><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>在行尾添加两个空格加回车表示换行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一行后面加两个空格  </span><br><span class="line">换行</span><br></pre></td></tr></table></figure></p><p>效果如下：<br>这是一行后面加两个空格<br>换行</p><h2 id="脚注-注解"><a href="#脚注-注解" class="headerlink" title="脚注(注解)"></a>脚注(注解)</h2><p>使用[^]来定义脚注：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是一个脚注的例子[^1]</span><br><span class="line"></span><br><span class="line">[^1]: 这里是脚注</span><br></pre></td></tr></table></figure></p><p>效果如下：<br>这是一个脚注的例子<a href="这里是脚注">^1</a>  </p><hr><h2 id="常用弥补Markdown的Html标签"><a href="#常用弥补Markdown的Html标签" class="headerlink" title="常用弥补Markdown的Html标签"></a>常用弥补Markdown的Html标签</h2><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face=&quot;微软雅黑&quot; color=&quot;red&quot; size=&quot;6&quot;&gt;字体及字体颜色和大小&lt;/font&gt;</span><br><span class="line">&lt;font color=&quot;#0000ff&quot;&gt;字体颜色&lt;/font&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><font face="微软雅黑" color="red" size="6">字体及字体颜色和大小</font></p><p><font color="#0000ff">字体颜色</font></p><hr><h3 id="换行-1"><a href="#换行-1" class="headerlink" title="换行"></a>换行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用html标签`&lt;br/&gt;`&lt;br/&gt;换行</span><br></pre></td></tr></table></figure><p>效果如下</p><p>使用html标签<code>&lt;br/&gt;</code><br>换行</p><hr><h3 id="文本对齐方式"><a href="#文本对齐方式" class="headerlink" title="文本对齐方式"></a>文本对齐方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;p align=&quot;left&quot;&gt;居左文本&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;center&quot;&gt;居中文本&lt;/p&gt;</span><br><span class="line">&lt;p align=&quot;right&quot;&gt;居右文本&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>效果如下：  </p><p align="left">居左文本</p><br><p align="center">居中文本</p><br><p align="right">居右文本</p><hr><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;下划线文本&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>效果如下：  </p><p><u>下划线文本</u></p><hr><h3 id="That’s-all-Enjoy-it"><a href="#That’s-all-Enjoy-it" class="headerlink" title="That’s all, Enjoy it!"></a>That’s all, Enjoy it!</h3><h3 id="备注：文末有些html标签在简书上不支持，同时，本文提供Markdown源文件，需要的请联系我！"><a href="#备注：文末有些html标签在简书上不支持，同时，本文提供Markdown源文件，需要的请联系我！" class="headerlink" title="备注：文末有些html标签在简书上不支持，同时，本文提供Markdown源文件，需要的请联系我！"></a>备注：文末有些html标签在简书上不支持，同时，本文提供Markdown源文件，需要的请联系我！</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Markdown 是一种轻量级标记语言，它用简洁的语法代替排版，使我们专心于码字。它的目标是实现易读易写，成为一种适用于网络的书写语言。同时，Markdown支持嵌入html标签。&lt;br&gt;注意：Markdown使用#、+、*等符号来标记， 符号后面必须跟上 至少1个 空格才有效！&lt;/p&gt;
    
    </summary>
    
      <category term="markdown" scheme="http://xiao-chengang.github.io/categories/markdown/"/>
    
    
      <category term="语法" scheme="http://xiao-chengang.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
      <category term="markdown" scheme="http://xiao-chengang.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>前端开发技巧一</title>
    <link href="http://xiao-chengang.github.io/2018/01/18/web-skill1/"/>
    <id>http://xiao-chengang.github.io/2018/01/18/web-skill1/</id>
    <published>2018-01-18T07:36:04.000Z</published>
    <updated>2018-03-20T12:27:00.000Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>禁用电话、邮箱自动识别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"telephone=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"email=no"</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>获取滚动条的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.scrollY</span><br><span class="line"><span class="built_in">window</span>.scrollX</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>禁止选择文本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-user-select</span>: <span class="selector-tag">none</span></span><br></pre></td></tr></table></figure></li><li><p>重置按钮样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">-webkit-appearance</span>: <span class="selector-tag">none</span></span><br></pre></td></tr></table></figure></li><li><p>多文本换行</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span> : <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 2;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br></pre></td></tr></table></figure></li><li><p>快速回弹滚动<br>在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">auto</span>;</span><br><span class="line"><span class="selector-tag">-webkit-overflow-scrolling</span>: <span class="selector-tag">touch</span>;</span><br></pre></td></tr></table></figure></li></ul><p>对于body滚动，ios8以上，不加此效果同样拥有弹性滚动效果。</p><ul><li>ios和android局部滚动时隐藏原生滚动条<br>android:<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::-webkit-scrollbar</span>&#123;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>ios:<br>使用一个稍微高一些div包裹住这个有滚动条的div然后设置overflow:hidden挡住之<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="built_in">-webkit-calc</span>(100% + 5px);</span><br><span class="line">    <span class="attribute">overflow-x</span>: auto;</span><br><span class="line">    <span class="attribute">overflow-y</span>: hidden;</span><br><span class="line">    <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;p&gt;禁用电话、邮箱自动识别&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;telephone=no&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;format-detection&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;meta&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;content&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;email=no&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;format-detection&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;获取滚动条的值&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.scrollY&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.scrollX&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="web" scheme="http://xiao-chengang.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://xiao-chengang.github.io/tags/web/"/>
    
      <category term="html" scheme="http://xiao-chengang.github.io/tags/html/"/>
    
      <category term="css" scheme="http://xiao-chengang.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端开发技巧二</title>
    <link href="http://xiao-chengang.github.io/2018/01/17/web-skill2/"/>
    <id>http://xiao-chengang.github.io/2018/01/17/web-skill2/</id>
    <published>2018-01-17T07:36:04.000Z</published>
    <updated>2018-03-20T12:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>你曾经看着自己喜爱的网站，是不是想知道它到底是怎么运作的？你看它的布局方式，当你点击按钮的时候的交互，或者其他的部分，有没想过：“我想知道它到底有多么复杂”或者“我希望我也能做到”？</p><p>所有的这些事情都属于前端开发的范畴。虽然网页设计决定网站的外观，但是实现这个网页设计需要前端开发。<br><a id="more"></a><br>前端开发者们使用HTML, CSS, 和JavaScript编写通过网页设计师所创建的web应用程序的设计。他们编写的代码运行在用户浏览器的内部(相反，后端开发人员的代码在web服务器上运行)，想象一下这样的场景：后端开发者就像一个工程师，他们设计和创造让一个城市工作的系统(电力，供水和下水道，分区等)，而前端开发者则规划街道，并确保连接好一切，让人们能过自己的生活(一个简单的比喻，但你能得到一个粗略的概念)，他们还负责确保在前端没有错误和bug，以及确保设计师设计的网页能支持各种平台和浏览器。</p><p>我通过梳理几十个前端开发的工作清单，为了看看目前最需要哪些技能。下面这些是真正的雇主在求职者中寻找的东西(在不久的将来仍然一样)，掌握了下面的这些技能，你肯定能找到一个很棒的前端开发的工作！</p><h3 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3><p>HTML (Hyper Text Markup Language) 和 CSS (Cascading Style Sheets)，是网站编码的最基本的部分。没有这两样东西，你不能完成一个网站的设计，你最终只能在屏幕上看到一个无格式的纯文本。没有HTML，你甚至不能在页面中添加图片。</p><p>在你开始任何web开发的职业道路之前，你都必须要掌握HTML和CSS。好消息是通过短短几周，不管是HTML还是CSS，你就能得到扎实的实践经验。</p><p>最重要的部分：单独的HTML和CSS知识能让你建立基础的网站。</p><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>JavaScript能为你的网站添加大量的功能。你甚至能够开发很多基本的web应用程序，仅仅只使用HTML, CSS和 JavaScript(简称JS)。在最基本的层面上，JS能够添加很多互动的元素到你的网站，使用它开发实时更新的地图，<a href="http://www.jacktorrancetrip.com/" target="_blank" rel="noopener">互动电影</a>，和线上游戏。像<a href="https://www.pinterest.com" target="_blank" rel="noopener">pinterest</a>这个网站使用JS让他们的用户使用起来非常简单(事实上，不管你什么时候钉住一张图片页面都不会刷新，这要多亏于JS)。</p><p>它是世界上最受欢迎的编程语言，所以无论你作为开发者的职业生涯如何规划，这是一个非常值得学习的东西。</p><p>更多关于JS的文章在这里： <a href="https://skillcrush.com/2013/04/15/youve-learned-html-css-now-what/" target="_blank" rel="noopener">You’ve Learned HTML and CSS—Now What?</a></p><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>jQuery是一个JavaScript库：一个插件和扩展的集合，让开发者写JavaScript更快更简单。而不是从头开始编码，jQuery让你添加现有的元素到你的项目中，在必要的时候你也能够定制开发(这是为什么学习JS如此重要的原因之一)。你能使用jQuery做这些事情，比如<a href="http://tutorialzine.com/2011/12/countdown-jquery/" target="_blank" rel="noopener">倒计时</a>，<a href="http://twitter.github.io/typeahead.js/" target="_blank" rel="noopener">自动完成的搜索表单</a>，甚至是自动调整大小的<a href="http://gridster.net/" target="_blank" rel="noopener">栅格布局</a>。</p><h3 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h3><p>JS框架(包括AngularJS, Backbone, Ember, 和ReactJS等)能让你的JS代码有一个现成的架构。虽然之前提到的4个是实际的工作清单上最受欢迎的框架，但是根据不同的需求有不同的框架。这些框架真的能让你的开发速度变的更快，就像jQuery一样，让你从头开始编码做的事情更少。</p><h3 id="CSS框架"><a href="#CSS框架" class="headerlink" title="CSS框架"></a>CSS框架</h3><p>CSS框架(最受欢迎的是Bootstrap)是为了写CSS更加简单，如同JS框架是为了JS。它们给你一个更快的编码起点，因为很多的CSS在一个又一个的项目中使用相同的元素，框架在前期为你定义了所有的元素。很多的前端工作清单上都希望你能够熟练掌握怎么使用它们，以及了解它们的工作原理。</p><h3 id="CSS预处理器的经验"><a href="#CSS预处理器的经验" class="headerlink" title="CSS预处理器的经验"></a>CSS预处理器的经验</h3><p>预处理器是另一个加快你CSS编码的东西。CSS预处理器能够给你的CSS添加额外的功能，让我们的CSS可扩展，并且更容易工作。它在你发布网站之前加工你的代码，让它变成格式更美观的、跨浏览器友好的CSS。根据真实的工作清单，SASS和LESS是需求最高的预处理器。</p><h3 id="RESTful服务和APIs的经验"><a href="#RESTful服务和APIs的经验" class="headerlink" title="RESTful服务和APIs的经验"></a>RESTful服务和APIs的经验</h3><p>在这一点，没有太多技术性。REST代表特征状态转移，英文是Representational State Transfer。从基本术语来说，它是一个轻量级的架构，简化了web的网络连接，RESTful服务和APIs都是REST架构的部分。查阅更多关于REST和RESTful服务，请看<a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank" rel="noopener">这里</a>。</p><p>假设你想写一个程序，展示你所有的社交媒体的朋友的交往顺序，你应该调用Facebook的RESTful接口读取你朋友的列表，并且返回这些数据，Twitter亦然(也要调用RESTful接口)。使用RESTful接口服务的流程一般都是一样的，只是返回的数据不同。</p><p>尽管听起来像很复杂的技术，但它只是一组简单的指导方针，让你知道如何与Web服务进行通信的准则和做法。它们还让你Web服务有更好的表现，规模更好，工作更可靠，而且更容易修改或移动。</p><h3 id="响应式和移动端设计"><a href="#响应式和移动端设计" class="headerlink" title="响应式和移动端设计"></a>响应式和移动端设计</h3><p>就美国而言，使用手机上网的人数超过了用电脑上网的人数。所以不用说，响应式和移动端设计对雇主而言是非常重要的。响应式设计意味布局(有时候还有功能和内容)随着屏幕大小、设备的改变而改变。</p><p>举个例子，当一个网站是被大屏幕的电脑访问时，用户将会看到更多的列，大的图像，以及专门为鼠标和键盘创建的交互。在移动设备上，同样的网站可能只有1列，并且优化成触摸交互，但是使用同样的基本文件。</p><p>移动端设计不仅包括响应式设计，而且还包括创建单独的针对移动设备的设计。有时候你想要用户访问你的站点时，用电脑和智能手机所看到的是完全不同的，在这种情况下，移动端的网站是有意义的。举个例子，银行的线上银行网站，使用单独的移动站点是有很多好处的，它让用户看到距离最近的银行的位置，简化账户信息(因为移动设备屏幕更小)。</p><p>如果你想学习更多的响应式设计，查阅我们的文章，<a href="http://skillcrush.com/blueprint/mobile-web-designer/" target="_blank" rel="noopener">mobile-web-designer</a>，或者 <a href="https://skillcrush.com/2015/04/07/8-secrets-to-mobile-design/" target="_blank" rel="noopener">8 Secrets To Building Mobile Sites Users Love</a>。</p><h3 id="跨浏览器开发"><a href="#跨浏览器开发" class="headerlink" title="跨浏览器开发"></a>跨浏览器开发</h3><p>现代的浏览器在展示网站的一致性上非常的好，但是它们如何解析代码并呈现在屏幕前仍然有一些不同。直到所有的现代浏览器都使用web标准，并能完美的工作之前，知道如何让每一个浏览器都像你期望的那样运行，是非常重要的技能。这就是所有跨浏览器开发的内容。</p><p>查看更多的跨浏览器的兼容性请看<a href="https://en.wikipedia.org/wiki/Cross-browser" target="_blank" rel="noopener">这里</a>或者<a href="https://developer.mozilla.org/en-US/docs/Using_Web_Standards_in_your_Web_Pages/Developing_cross-browser_and_cross-platform_pages" target="_blank" rel="noopener">这里</a>，或者查看更深层次的Daniel Herken的文章<a href="http://www.crossbrowserbook.com/" target="_blank" rel="noopener">Cross Browser Handbook</a>。</p><h3 id="内容管理系统和E-commerce平台"><a href="#内容管理系统和E-commerce平台" class="headerlink" title="内容管理系统和E-commerce平台"></a>内容管理系统和E-commerce平台</h3><p>几乎所有的站点都是建立在内容管理系统(CMS)之上的(E-commerce平台是一个CMS具体的类型)。世界上最受欢迎的CMS是WordPress，它在成千上万的网站的幕后工作(包括Skillcrush！)——60%的CMS网站使用WordPress。</p><p>其他的受欢迎的CMS包括Joomla、Drupal和Magento。尽管知道这些不会让你成为一个WordPress专家，但是它们能让你在使用这些系统的公司(而且很多公司在使用)，找到一份令人满意的工作。</p><h3 id="测试和调试"><a href="#测试和调试" class="headerlink" title="测试和调试"></a>测试和调试</h3><p>这是一个web开发中的事实：产生bug。熟悉测试和调试的过程是至关重要的。</p><p>单元测试是分快测试源代码的过程(这些指令告诉网站要如何工作)。单元测试框架提供一个特殊的方法和架构做这些事情(每个不同的编程语言测试框架也有不同)。</p><p>另一个测试类型是UI测试(也叫验收测试、浏览器测试或者功能测试)，你用它能够察实际情况中，用户在网站行为交互是否正确。你可以编写测试代码，在一个页面发生一个动作之后，寻找特定的HTML(比如如果用户忘记填写必填的表单，一个表单错误的提示框将会弹出)。</p><p>调试(Debugging)简单的说，就是通过测试发现所有的bug和错误(或者你的网站发布后被你的用户发现)，侦测并且知道为什么它们会发生，然后修复这个问题。不同的公司的流程可能稍微有些不同，但只要你掌握了一个，也能很容易适应其他的。</p><h3 id="Git和版本控制系统"><a href="#Git和版本控制系统" class="headerlink" title="Git和版本控制系统"></a>Git和版本控制系统</h3><p>版本控制系统能让你追踪过去的代码，如果你把事情搞砸了，它们也能很容易的让你回退到一个早期的版本。假设你添加了一个自定义的jQuery插件，写到一半突然发现其他的代码出问题了，你能够实用版本控制系统回滚到之前的版本然后用不同的方式再试一次，而不是手动的撤销它然后再修复问题。</p><p>Git是一个被广泛使用的版本控制系统。了解并且知道如何使用Git几乎是所有开发工作的要求之一。这是一个开发者需要的至关重要的技能，但是很少被提及。</p><h3 id="解决问题的能力"><a href="#解决问题的能力" class="headerlink" title="解决问题的能力"></a>解决问题的能力</h3><p>有一个东西不管工作描述还是官方标题，是要求所有前端开发者必须拥有的，那就是优秀的解决问题的能力。从找到如何让设计最好的实现，到修复那些突然出现的错误，到结合前端代码和后端代码一起工作，开发就是解决这些过程中所有的问题。</p><p>假设你创建了一个有完美功能的前端网站，然后你把它交给后端开发者让他们整合到内容管理系统。突然之间，你那些很棒的功能停止工作了，一个好的前端开发者会把它视为一个谜题并且解决它，而不是形成一个灾难。当然，一个优秀的高级前端开发者会预测到这些问题，并且在第一时间阻止它们发生。</p><blockquote><p>原文地址： <a href="https://skillcrush.com/2016/02/11/skills-to-become-a-front-end-developer/" target="_blank" rel="noopener">Exactly What You Need to Know to be a Front End Developer</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;你曾经看着自己喜爱的网站，是不是想知道它到底是怎么运作的？你看它的布局方式，当你点击按钮的时候的交互，或者其他的部分，有没想过：“我想知道它到底有多么复杂”或者“我希望我也能做到”？&lt;/p&gt;
&lt;p&gt;所有的这些事情都属于前端开发的范畴。虽然网页设计决定网站的外观，但是实现这个网页设计需要前端开发。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://xiao-chengang.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://xiao-chengang.github.io/tags/web/"/>
    
      <category term="语法" scheme="http://xiao-chengang.github.io/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
